{"ast":null,"code":"import { HttpHeaders, HttpParams } from '@angular/common/http';\nimport { of } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"../../message.service\";\nexport class LoginService {\n  constructor(http, messageService) {\n    this.http = http;\n    this.messageService = messageService;\n    this.baseUrl = 'http://127.0.0.1:5000';\n    this.corsHeaders = new HttpHeaders({\n      'Content-Type': 'application/json',\n      'Access-Control-Allow-Origin': '*'\n    });\n  }\n  getRecommendedEvents(event) {\n    const url = this.baseUrl;\n    const params = new HttpParams().set('event', JSON.stringify(event));\n    const options = {\n      headers: this.corsHeaders,\n      params\n    };\n    console.log(JSON.stringify(event));\n    return this.http.get(url + '/getRecommendedEventsForUser', options);\n  }\n  /**\n  * Handle Http operation that failed.\n  * Let the app continue.\n  *\n  * @param operation - name of the operation that failed\n  * @param result - optional value to return as the observable result\n  */\n  handleError(operation = 'operation', result) {\n    return error => {\n      // TODO: send the error to remote logging infrastructure\n      console.error(error); // log to console instead\n      // TODO: better job of transforming error for user consumption\n      this.log(`${operation} failed: ${error.message}`);\n      // Let the app keep running by returning an empty result.\n      return of(result);\n    };\n  }\n  /** Log a HeroService message with the MessageService */\n  log(message) {\n    this.messageService.add(`HeroService: ${message}`);\n  }\n}\nLoginService.ɵfac = function LoginService_Factory(t) {\n  return new (t || LoginService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.MessageService));\n};\nLoginService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: LoginService,\n  factory: LoginService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"AACA,SAAqBA,WAAW,EAACC,UAAU,QAAQ,sBAAsB;AACzE,SAAqBC,EAAE,QAAQ,MAAM;;;;AAUrC,OAAM,MAAOC,YAAY;EAUvBC,YACUC,IAAgB,EAChBC,cAA8B;IAD9B,SAAI,GAAJD,IAAI;IACJ,mBAAc,GAAdC,cAAc;IAXhB,YAAO,GAAG,uBAAuB;IAGjC,gBAAW,GAAG,IAAIN,WAAW,CAAC;MACpC,cAAc,EAAE,kBAAkB;MAClC,6BAA6B,EAAE;KAChC,CAAC;EAOC;EAIHO,oBAAoB,CAACC,KAAY;IAC/B,MAAMC,GAAG,GAAG,IAAI,CAACC,OAAO;IACxB,MAAMC,MAAM,GAAe,IAAIV,UAAU,EAAE,CAACW,GAAG,CAAC,OAAO,EAAEC,IAAI,CAACC,SAAS,CAACN,KAAK,CAAC,CAAC;IAC/E,MAAMO,OAAO,GAAG;MACdC,OAAO,EAAE,IAAI,CAACC,WAAW;MACzBN;KACD;IACDO,OAAO,CAACC,GAAG,CAACN,IAAI,CAACC,SAAS,CAACN,KAAK,CAAC,CAAC;IAClC,OAAO,IAAI,CAACH,IAAI,CAACe,GAAG,CAAUX,GAAG,GAAC,8BAA8B,EAACM,OAAO,CAAC;EAC3E;EAEE;;;;;;;EAOQM,WAAW,CAAIC,SAAS,GAAG,WAAW,EAAEC,MAAU;IACxD,OAAQC,KAAU,IAAmB;MAEnC;MACAN,OAAO,CAACM,KAAK,CAACA,KAAK,CAAC,CAAC,CAAC;MAEtB;MACA,IAAI,CAACL,GAAG,CAAC,GAAGG,SAAS,YAAYE,KAAK,CAACC,OAAO,EAAE,CAAC;MAEjD;MACA,OAAOvB,EAAE,CAACqB,MAAW,CAAC;IACxB,CAAC;EACL;EAEE;EACQJ,GAAG,CAACM,OAAe;IACzB,IAAI,CAACnB,cAAc,CAACoB,GAAG,CAAC,gBAAgBD,OAAO,EAAE,CAAC;EACpD;;AArDStB,YAAY;mBAAZA,YAAY;AAAA;AAAZA,YAAY;SAAZA,YAAY;EAAAwB,SAAZxB,YAAY;EAAAyB,YAFX;AAAM","names":["HttpHeaders","HttpParams","of","LoginService","constructor","http","messageService","getRecommendedEvents","event","url","baseUrl","params","set","JSON","stringify","options","headers","corsHeaders","console","log","get","handleError","operation","result","error","message","add","factory","providedIn"],"sourceRoot":"","sources":["/Users/suvijain/Documents/GitHub/brickhack/eventify-demo/src/app/login/login.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders,HttpParams } from '@angular/common/http';\nimport { Observable, of } from 'rxjs';\nimport { catchError, map, tap } from 'rxjs/operators';\nimport { LoginComponent } from './login.component';\nimport { User } from '../Models/User';\nimport { Event } from '../Models/Event';\nimport { MessageService } from '../../message.service'\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LoginService {\n  private baseUrl = 'http://127.0.0.1:5000';\n  \n\n  private corsHeaders = new HttpHeaders({\n    'Content-Type': 'application/json',\n    'Access-Control-Allow-Origin': '*'\n  });\n  \n\n  constructor(\n    private http: HttpClient,\n    private messageService: MessageService,\n    \n  ) {}\n  \n\n  \n  getRecommendedEvents(event: Event): Observable<Event[]> {\n    const url = this.baseUrl;\n    const params: HttpParams = new HttpParams().set('event', JSON.stringify(event));\n    const options = {\n      headers: this.corsHeaders,\n      params\n    };\n    console.log(JSON.stringify(event))\n    return this.http.get<Event[]>(url+'/getRecommendedEventsForUser',options);\n  }\n\n    /**\n   * Handle Http operation that failed.\n   * Let the app continue.\n   *\n   * @param operation - name of the operation that failed\n   * @param result - optional value to return as the observable result\n   */\n    private handleError<T>(operation = 'operation', result?: T) {\n      return (error: any): Observable<T> => {\n  \n        // TODO: send the error to remote logging infrastructure\n        console.error(error); // log to console instead\n  \n        // TODO: better job of transforming error for user consumption\n        this.log(`${operation} failed: ${error.message}`);\n  \n        // Let the app keep running by returning an empty result.\n        return of(result as T);\n      };\n  }\n  \n    /** Log a HeroService message with the MessageService */\n    private log(message: string) {\n      this.messageService.add(`HeroService: ${message}`);\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}